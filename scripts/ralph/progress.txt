# Ralph Progress Log
Started: 2026-01-07

## Codebase Patterns
- App Router: Use `src/app` structure with Next.js 15
- Styling: Tailwind CSS
- AI: Gemini 2.5 Flash via Vertex AI (@google/genai)
- Persistence: JSON files in `src/lib/model/data`
- Components: Use Radix UI / Shadcn UI patterns where applicable
- Types: Export from `src/lib/model/types.ts`

## Domain: Item Types & IDs (Cookbook)
Items have 7-digit IDs where the first digit(s) signify the type:
- **5\*** = Ingredients (raw, lowest-level, procured externally)
- **3\*** = Benchtop recipes (R&D reference only, not production)
- **40\*** = Consumable Items (components in menu item BOMs)
- **80\*** = Menu items (have line builds, used in Spork for food production)
- **88\*** = Packaged goods (items we produce)
- **9\*** = Guest packaging items

## Domain: BOM Structure
- **Menu items (80\*)** have BOMs containing **40\* consumable items**
- BOM contains: input item IDs, quantities, units of measure, output amounts
- **Publishing Order**: Cannot publish if BOM contains draft items
- **Cost Flow**: Costs roll up from base items
- **Nutrition Flow**: Nutrition values flow through BOM hierarchy

## Key Files
- apps/archive-benchtop-mvp/ (Reference for porting logic)
- apps/archive-benchtop-mvp/src/lib/ai/vertex/client.ts (Vertex AI setup)
- apps/archive-benchtop-mvp/src/lib/model/types.ts (Type definitions)
- docs/PRD.md (Main reference for requirements)

## BD Commands
- `bd ready --json` — Get tasks ready to work on
- `bd show <id>` — Full issue details
- `bd update <id> --status in_progress` — Claim task
- `bd close <id>` — Mark complete
- `bd dep tree <id>` — Visualize dependencies

---
Ralph appends after each story.
Patterns accumulate across iterations.

## Jan 7, 2026 - benchtop-x0c.1.1: Scaffold new Next.js app (apps/line-build-mvp)

### What I Implemented:
- Created new Next.js 15 app in `apps/line-build-mvp` using create-next-app
- Configured with TypeScript, Tailwind CSS, ESLint, App Router, and src-dir structure
- Imported alias set to @/* for cleaner imports

### Files Changed:
- `apps/line-build-mvp/` — Complete new Next.js application scaffold

### Learnings (for next iteration):
- create-next-app with `--app --src-dir --import-alias '@/*'` creates the base structure needed
- Foundation ready for subsequent tasks (Vertex AI, CopilotKit, types, etc.)
- The app is now ready for dependency installations

### Codebase Patterns Discovered:
- Next.js setup: Use create-next-app with --app, --src-dir, --import-alias, --typescript, --tailwind flags

---

## Jan 7, 2026 - benchtop-x0c.1.2: Integrate Vertex AI client (Gemini)

### What I Implemented:
- Created Vertex AI client wrapper in `src/lib/ai/vertex/client.ts`
- Installed @google/genai package for Vertex AI/Gemini integration
- Implemented VertexAIClient class with generateContent method
- Added createVertexAIClient factory function with environment variable support

### Files Changed:
- `apps/line-build-mvp/src/lib/ai/vertex/client.ts` — Vertex AI client wrapper
- `apps/line-build-mvp/package.json` — Added @google/genai dependency

### Learnings (for next iteration):
- Use generateContentStream() instead of generateContent() for streaming responses (fixes async iterator type issues)
- Environment variables needed: VERTEX_AI_PROJECT, VERTEX_AI_LOCATION (default: us-central1), VERTEX_AI_MODEL (default: gemini-2.5-flash)
- GOOGLE_APPLICATION_CREDENTIALS environment variable handles authentication automatically
- The GoogleGenAI SDK handles Vertex AI routing automatically with vertexai: true flag

### Codebase Patterns Discovered:
- AI Integration: Use @google/genai with GoogleGenAI class and generateContentStream() for Vertex AI
- Config Pattern: Read environment variables with sensible defaults
- Error Handling: Wrap try/catch around AI calls with meaningful error messages

---

## Jan 7, 2026 - benchtop-x0c.1.3: Integrate CopilotKit (chat + tool actions)

### What I Implemented:
- Installed CopilotKit packages: @copilotkit/react-core, @copilotkit/react-ui, @copilotkit/runtime
- Created CopilotKitProvider wrapper component at `src/components/CopilotKitProvider.tsx`
- Wrapped root layout with CopilotKitProvider for app-wide chat availability
- Created placeholder API route at `src/app/api/copilotkit/route.ts` for backend integration

### Files Changed:
- `apps/line-build-mvp/src/components/CopilotKitProvider.tsx` — Client-side CopilotKit wrapper
- `apps/line-build-mvp/src/app/api/copilotkit/route.ts` — Placeholder backend route
- `apps/line-build-mvp/src/app/layout.tsx` — Wrapped with CopilotKitProvider
- `apps/line-build-mvp/package.json` — Added CopilotKit dependencies

### Learnings (for next iteration):
- CopilotKit requires '@copilotkit/react-ui/styles.css' import for styling
- CopilotKit v1.50.1+ ships with React 19 support (different from reference's v1.0.0)
- Provider wraps entire app at root layout for chat availability across all pages
- API route should handle POST requests to /api/copilotkit (placeholder ready for full implementation)
- Full backend integration will be done when CopilotKit actions are defined (benchtop-x0c.5.4)

### Codebase Patterns Discovered:
- CopilotKit Setup: Install packages, create Provider wrapper component, import styles.css
- Provider Pattern: Use 'use client' directive in provider component for client-side setup
- API Route Pattern: Create route handler at src/app/api/[name]/route.ts for Next.js 15+

---

## Jan 7, 2026 - benchtop-x0c.1.4: Define core types (LineBuild, WorkUnit, Override, ValidationRule)

### What I Implemented:
- Created comprehensive types file at `src/lib/model/types.ts`
- Defined LineBuild and WorkUnit types (based on reference implementation)
- Defined Override type for form field overrides with audit trail
- Defined ValidationRule types (StructuredValidationRule and SemanticValidationRule)
- Defined ValidationResult and BuildValidationStatus types for validation output
- All types follow TypeScript best practices with clear field descriptions

### Files Changed:
- `apps/line-build-mvp/src/lib/model/types.ts` — Complete type definitions for MVP

### Learnings (for next iteration):
- LineBuild uses status: "draft" | "active" (not "published" from reference)
- ValidationRule split into two types: structured (condition-based) and semantic (Gemini-based)
- StructuredValidationRule uses condition object with field/operator/value for rule logic
- SemanticValidationRule uses prompt/guidance for Gemini evaluation
- ValidationResult includes ruleType, reasoning field (for semantic rules), and timestamp
- Override tracks original/overridden values with timestamps for audit trail
- All date fields use ISO 8601 string format

### Codebase Patterns Discovered:
- Types: Export all types from src/lib/model/types.ts
- Type Organization: Group related types with section headers (// ========)
- Discriminated Unions: Use ValidationRuleType discriminator for rule type checking
- Status Enums: Use literal unions for status fields instead of string enums (more flexible)

---

## Jan 7, 2026 - benchtop-x0c.2.1: Implement JSON persistence for line builds

### What I Implemented:
- Created LineBuildPersistence class for save/load/delete operations on LineBuild objects
- Implemented timestamped backup system to prevent data loss and conflicts
- Added graceful error handling for corrupted JSON files with automatic recovery from backups
- Support for both Node.js (fs module) and browser (localStorage) storage backends
- Human-readable JSON formatting (2-space indent) for debugging and manual inspection
- Factory functions for instance management (getPersistence singleton, createPersistence for testing)
- Validation of LineBuild structure during load with meaningful error messages

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/persistence.ts` — Complete persistence implementation

### Learnings (for next iteration):
- Dual-environment persistence: Use dynamic imports (fs/promises, path) for Node.js detection
- Backups saved with timestamp pattern: `filename.backup.YYYY-MM-DDTHH-mm-ss` for sorting
- Corrupted file recovery: Try most recent backup first, skip to next on parse error
- Type assertion workaround: Use `as unknown as LineBuild` for complex destructuring patterns
- Directory creation: Use `fs.mkdir(..., { recursive: true })` for safe multi-path creation
- Error messages should include the buildId and operation context for debugging

### Codebase Patterns Discovered:
- Persistence API: Class-based with async methods matching save/load/delete/exists operations
- File Naming: Use buildId directly as filename (e.g., `build-123.json`)
- Environment Detection: Check `typeof window === "undefined"` to distinguish server/client
- Backup Storage: Keep backups in same directory with timestamp suffix for versioning
- Error Recovery: Three-tier strategy: primary file → recent backups → meaningful error message

---

## Jan 7, 2026 - benchtop-x0c.1.5: Create mock BOM dataset (7-digit itemId + name)

### What I Implemented:
- Created mock BOM catalog with realistic 7-digit item IDs following Cookbook conventions
- Defined items across all categories: menu items (80*), consumables (40*), ingredients (5*), packaged goods (88*), packaging (9*)
- Implemented 8 realistic menu items with complete names: "Grilled Chicken Bowl", "Crispy Fish Tacos", etc.
- Implemented 17 consumable items organized by type (proteins, vegetables, rice/noodles, sauces)
- Created 8 BOM recipes mapping menu items to their consumable components with realistic quantities
- Exported helper functions for easy access: getAllBOMItems, findBOMItem, getBOMRecipe, getItemTypeFromId

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/mockBom.ts` — Complete mock BOM dataset

### Learnings (for next iteration):
- Item ID prefixes are critical: 5* = ingredient, 40* = consumable, 80* = menu, 88* = packaged, 9* = packaging
- BOM relationships are unidirectional: menu items (80*) reference consumable items (40*)
- Consumable organization by category (proteins, vegetables, etc.) makes data more maintainable
- Helper functions reduce boilerplate in other components (forms, validation, autocomplete)
- Mock data should include realistic quantities and units (g, ml) for validator testing
- Export the entire catalog as MOCK_BOM_CATALOG object for easy integration

### Codebase Patterns Discovered:
- Mock Data Export: Define data as const arrays, export individually AND as aggregate object
- Helper Functions: Provide utility functions (findByID, getByType) for common queries
- Type Organization: Use interfaces for item structure (BOMItem, BOMRecipe) at top of file
- Naming: Use uppercase SNAKE_CASE for exported constants, lowercase camelCase for functions

---

## Jan 7, 2026 - benchtop-x0c.2.3: Implement JSON persistence for validation rules

### What I Implemented:
- Created ValidationRulesPersistence class for managing ValidationRule objects (both structured and semantic)
- Implemented full CRUD operations: saveRule, saveRules, loadAll, loadRule, loadRulesByType, updateRule, deleteRule
- Added backup and corruption recovery mechanisms (same pattern as LineBuildPersistence)
- Rules persisted as collection in single JSON file with metadata wrapper
- Type validation distinguishes between structured rules (with condition) and semantic rules (with prompt)
- Support for both server (fs) and client (localStorage) storage backends
- Singleton and test instance factory functions (getRulesPersistence, createRulesPersistence)

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/rulesPersistence.ts` — Complete rules persistence implementation

### Learnings (for next iteration):
- Rules collection pattern: Store all rules in single file (validation-rules.json) rather than per-rule files
- Metadata wrapper: Use {rules: [...], _metadata: {...}} pattern to include save timestamp and rule count
- Type guards: Use discriminated unions (type: "structured" | "semantic") to validate rule types
- Update merging: Use `as ValidationRule` type assertion after spreading to resolve complex union issues
- localStorage key prefix: Use "valrules:" prefix to avoid conflicts with other persistence layers
- Backup naming: Timestamp backups enable easy recovery of specific versions
- Load handling: Support both direct array [] and wrapped {rules: [...]} formats for flexibility

### Codebase Patterns Discovered:
- Rules Storage: Single collection file is better than per-rule files for managing relationships
- Type Validation: Discriminated union types (type field) enable clean type narrowing
- Error Recovery: Same three-tier strategy as LineBuildPersistence (primary → backup → error)
- localStorage Strategy: Use domain-specific prefixes (valrules:, linebuild:) to organize data
- Metadata Tracking: Include savedAt, version, and entity count in metadata for debugging

---
