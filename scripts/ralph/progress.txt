# Ralph Progress Log
Started: 2026-01-07

## Codebase Patterns
- App Router: Use `src/app` structure with Next.js 15
- Styling: Tailwind CSS
- AI: Gemini 2.5 Flash via Vertex AI (@google/genai)
- Persistence: JSON files in `src/lib/model/data`
- Components: Use Radix UI / Shadcn UI patterns where applicable
- Types: Export from `src/lib/model/types.ts`

## Domain: Item Types & IDs (Cookbook)
Items have 7-digit IDs where the first digit(s) signify the type:
- **5\*** = Ingredients (raw, lowest-level, procured externally)
- **3\*** = Benchtop recipes (R&D reference only, not production)
- **40\*** = Consumable Items (components in menu item BOMs)
- **80\*** = Menu items (have line builds, used in Spork for food production)
- **88\*** = Packaged goods (items we produce)
- **9\*** = Guest packaging items

## Domain: BOM Structure
- **Menu items (80\*)** have BOMs containing **40\* consumable items**
- BOM contains: input item IDs, quantities, units of measure, output amounts
- **Publishing Order**: Cannot publish if BOM contains draft items
- **Cost Flow**: Costs roll up from base items
- **Nutrition Flow**: Nutrition values flow through BOM hierarchy

## Key Files
- apps/archive-benchtop-mvp/ (Reference for porting logic)
- apps/archive-benchtop-mvp/src/lib/ai/vertex/client.ts (Vertex AI setup)
- apps/archive-benchtop-mvp/src/lib/model/types.ts (Type definitions)
- docs/PRD.md (Main reference for requirements)

## BD Commands
- `bd ready --json` — Get tasks ready to work on
- `bd show <id>` — Full issue details
- `bd update <id> --status in_progress` — Claim task
- `bd close <id>` — Mark complete
- `bd dep tree <id>` — Visualize dependencies

---
Ralph appends after each story.
Patterns accumulate across iterations.

## Jan 7, 2026 - benchtop-x0c.1.1: Scaffold new Next.js app (apps/line-build-mvp)

### What I Implemented:
- Created new Next.js 15 app in `apps/line-build-mvp` using create-next-app
- Configured with TypeScript, Tailwind CSS, ESLint, App Router, and src-dir structure
- Imported alias set to @/* for cleaner imports

### Files Changed:
- `apps/line-build-mvp/` — Complete new Next.js application scaffold

### Learnings (for next iteration):
- create-next-app with `--app --src-dir --import-alias '@/*'` creates the base structure needed
- Foundation ready for subsequent tasks (Vertex AI, CopilotKit, types, etc.)
- The app is now ready for dependency installations

### Codebase Patterns Discovered:
- Next.js setup: Use create-next-app with --app, --src-dir, --import-alias, --typescript, --tailwind flags

---

## Jan 7, 2026 - benchtop-x0c.1.2: Integrate Vertex AI client (Gemini)

### What I Implemented:
- Created Vertex AI client wrapper in `src/lib/ai/vertex/client.ts`
- Installed @google/genai package for Vertex AI/Gemini integration
- Implemented VertexAIClient class with generateContent method
- Added createVertexAIClient factory function with environment variable support

### Files Changed:
- `apps/line-build-mvp/src/lib/ai/vertex/client.ts` — Vertex AI client wrapper
- `apps/line-build-mvp/package.json` — Added @google/genai dependency

### Learnings (for next iteration):
- Use generateContentStream() instead of generateContent() for streaming responses (fixes async iterator type issues)
- Environment variables needed: VERTEX_AI_PROJECT, VERTEX_AI_LOCATION (default: us-central1), VERTEX_AI_MODEL (default: gemini-2.5-flash)
- GOOGLE_APPLICATION_CREDENTIALS environment variable handles authentication automatically
- The GoogleGenAI SDK handles Vertex AI routing automatically with vertexai: true flag

### Codebase Patterns Discovered:
- AI Integration: Use @google/genai with GoogleGenAI class and generateContentStream() for Vertex AI
- Config Pattern: Read environment variables with sensible defaults
- Error Handling: Wrap try/catch around AI calls with meaningful error messages

---

## Jan 7, 2026 - benchtop-x0c.1.3: Integrate CopilotKit (chat + tool actions)

### What I Implemented:
- Installed CopilotKit packages: @copilotkit/react-core, @copilotkit/react-ui, @copilotkit/runtime
- Created CopilotKitProvider wrapper component at `src/components/CopilotKitProvider.tsx`
- Wrapped root layout with CopilotKitProvider for app-wide chat availability
- Created placeholder API route at `src/app/api/copilotkit/route.ts` for backend integration

### Files Changed:
- `apps/line-build-mvp/src/components/CopilotKitProvider.tsx` — Client-side CopilotKit wrapper
- `apps/line-build-mvp/src/app/api/copilotkit/route.ts` — Placeholder backend route
- `apps/line-build-mvp/src/app/layout.tsx` — Wrapped with CopilotKitProvider
- `apps/line-build-mvp/package.json` — Added CopilotKit dependencies

### Learnings (for next iteration):
- CopilotKit requires '@copilotkit/react-ui/styles.css' import for styling
- CopilotKit v1.50.1+ ships with React 19 support (different from reference's v1.0.0)
- Provider wraps entire app at root layout for chat availability across all pages
- API route should handle POST requests to /api/copilotkit (placeholder ready for full implementation)
- Full backend integration will be done when CopilotKit actions are defined (benchtop-x0c.5.4)

### Codebase Patterns Discovered:
- CopilotKit Setup: Install packages, create Provider wrapper component, import styles.css
- Provider Pattern: Use 'use client' directive in provider component for client-side setup
- API Route Pattern: Create route handler at src/app/api/[name]/route.ts for Next.js 15+

---

## Jan 7, 2026 - benchtop-x0c.1.4: Define core types (LineBuild, WorkUnit, Override, ValidationRule)

### What I Implemented:
- Created comprehensive types file at `src/lib/model/types.ts`
- Defined LineBuild and WorkUnit types (based on reference implementation)
- Defined Override type for form field overrides with audit trail
- Defined ValidationRule types (StructuredValidationRule and SemanticValidationRule)
- Defined ValidationResult and BuildValidationStatus types for validation output
- All types follow TypeScript best practices with clear field descriptions

### Files Changed:
- `apps/line-build-mvp/src/lib/model/types.ts` — Complete type definitions for MVP

### Learnings (for next iteration):
- LineBuild uses status: "draft" | "active" (not "published" from reference)
- ValidationRule split into two types: structured (condition-based) and semantic (Gemini-based)
- StructuredValidationRule uses condition object with field/operator/value for rule logic
- SemanticValidationRule uses prompt/guidance for Gemini evaluation
- ValidationResult includes ruleType, reasoning field (for semantic rules), and timestamp
- Override tracks original/overridden values with timestamps for audit trail
- All date fields use ISO 8601 string format

### Codebase Patterns Discovered:
- Types: Export all types from src/lib/model/types.ts
- Type Organization: Group related types with section headers (// ========)
- Discriminated Unions: Use ValidationRuleType discriminator for rule type checking
- Status Enums: Use literal unions for status fields instead of string enums (more flexible)

---

## Jan 7, 2026 - benchtop-x0c.2.1: Implement JSON persistence for line builds

### What I Implemented:
- Created LineBuildPersistence class for save/load/delete operations on LineBuild objects
- Implemented timestamped backup system to prevent data loss and conflicts
- Added graceful error handling for corrupted JSON files with automatic recovery from backups
- Support for both Node.js (fs module) and browser (localStorage) storage backends
- Human-readable JSON formatting (2-space indent) for debugging and manual inspection
- Factory functions for instance management (getPersistence singleton, createPersistence for testing)
- Validation of LineBuild structure during load with meaningful error messages

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/persistence.ts` — Complete persistence implementation

### Learnings (for next iteration):
- Dual-environment persistence: Use dynamic imports (fs/promises, path) for Node.js detection
- Backups saved with timestamp pattern: `filename.backup.YYYY-MM-DDTHH-mm-ss` for sorting
- Corrupted file recovery: Try most recent backup first, skip to next on parse error
- Type assertion workaround: Use `as unknown as LineBuild` for complex destructuring patterns
- Directory creation: Use `fs.mkdir(..., { recursive: true })` for safe multi-path creation
- Error messages should include the buildId and operation context for debugging

### Codebase Patterns Discovered:
- Persistence API: Class-based with async methods matching save/load/delete/exists operations
- File Naming: Use buildId directly as filename (e.g., `build-123.json`)
- Environment Detection: Check `typeof window === "undefined"` to distinguish server/client
- Backup Storage: Keep backups in same directory with timestamp suffix for versioning
- Error Recovery: Three-tier strategy: primary file → recent backups → meaningful error message

---

## Jan 7, 2026 - benchtop-x0c.1.5: Create mock BOM dataset (7-digit itemId + name)

### What I Implemented:
- Created mock BOM catalog with realistic 7-digit item IDs following Cookbook conventions
- Defined items across all categories: menu items (80*), consumables (40*), ingredients (5*), packaged goods (88*), packaging (9*)
- Implemented 8 realistic menu items with complete names: "Grilled Chicken Bowl", "Crispy Fish Tacos", etc.
- Implemented 17 consumable items organized by type (proteins, vegetables, rice/noodles, sauces)
- Created 8 BOM recipes mapping menu items to their consumable components with realistic quantities
- Exported helper functions for easy access: getAllBOMItems, findBOMItem, getBOMRecipe, getItemTypeFromId

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/mockBom.ts` — Complete mock BOM dataset

### Learnings (for next iteration):
- Item ID prefixes are critical: 5* = ingredient, 40* = consumable, 80* = menu, 88* = packaged, 9* = packaging
- BOM relationships are unidirectional: menu items (80*) reference consumable items (40*)
- Consumable organization by category (proteins, vegetables, etc.) makes data more maintainable
- Helper functions reduce boilerplate in other components (forms, validation, autocomplete)
- Mock data should include realistic quantities and units (g, ml) for validator testing
- Export the entire catalog as MOCK_BOM_CATALOG object for easy integration

### Codebase Patterns Discovered:
- Mock Data Export: Define data as const arrays, export individually AND as aggregate object
- Helper Functions: Provide utility functions (findByID, getByType) for common queries
- Type Organization: Use interfaces for item structure (BOMItem, BOMRecipe) at top of file
- Naming: Use uppercase SNAKE_CASE for exported constants, lowercase camelCase for functions

---

## Jan 7, 2026 - benchtop-x0c.2.3: Implement JSON persistence for validation rules

### What I Implemented:
- Created ValidationRulesPersistence class for managing ValidationRule objects (both structured and semantic)
- Implemented full CRUD operations: saveRule, saveRules, loadAll, loadRule, loadRulesByType, updateRule, deleteRule
- Added backup and corruption recovery mechanisms (same pattern as LineBuildPersistence)
- Rules persisted as collection in single JSON file with metadata wrapper
- Type validation distinguishes between structured rules (with condition) and semantic rules (with prompt)
- Support for both server (fs) and client (localStorage) storage backends
- Singleton and test instance factory functions (getRulesPersistence, createRulesPersistence)

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/rulesPersistence.ts` — Complete rules persistence implementation

### Learnings (for next iteration):
- Rules collection pattern: Store all rules in single file (validation-rules.json) rather than per-rule files
- Metadata wrapper: Use {rules: [...], _metadata: {...}} pattern to include save timestamp and rule count
- Type guards: Use discriminated unions (type: "structured" | "semantic") to validate rule types
- Update merging: Use `as ValidationRule` type assertion after spreading to resolve complex union issues
- localStorage key prefix: Use "valrules:" prefix to avoid conflicts with other persistence layers
- Backup naming: Timestamp backups enable easy recovery of specific versions
- Load handling: Support both direct array [] and wrapped {rules: [...]} formats for flexibility

### Codebase Patterns Discovered:
- Rules Storage: Single collection file is better than per-rule files for managing relationships
- Type Validation: Discriminated union types (type field) enable clean type narrowing
- Error Recovery: Same three-tier strategy as LineBuildPersistence (primary → backup → error)
- localStorage Strategy: Use domain-specific prefixes (valrules:, linebuild:) to organize data
- Metadata Tracking: Include savedAt, version, and entity count in metadata for debugging

---

## Jan 7, 2026 - benchtop-x0c.2.2: Implement draft/active status model + transitions

### What I Implemented:
- Created BuildStatusManager class for enforcing state transitions with validation constraints
- Implemented transition rules: Active→Draft always allowed (demote without restriction), Draft→Active requires validation with zero failures
- Added canTransition for pre-flight checks and transitionTo for actual transitions with detailed blocking reasons
- Implemented applyTransition to safely apply status changes to LineBuild objects and persist in metadata
- Added UI helper functions: getStatusLabel, getStatusDescription, isEditableStatus, getSuggestedAction
- Implemented getPossibleTransitions to show available actions from current status
- Status persists in LineBuild.metadata.status (already supported by LineBuildPersistence)
- Validation constraints: requires BuildValidationStatus with !hasStructuredFailures && !hasSemanticFailures

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/statusManager.ts` — Complete status transition manager

### Learnings (for next iteration):
- Transition rules: Always provide detailed blocking reasons in StatusTransitionResult.reason field
- Validation coupling: Draft→Active transition depends on BuildValidationStatus, need to run validation first
- Metadata persistence: Status in LineBuild.metadata is persisted by LineBuildPersistence automatically
- UI helpers: Helper functions (getStatusLabel, getStatusDescription, getSuggestedAction) enable consistent UI display
- Immutability: Use spread operators to create new builds rather than mutating existing ones
- Type safety: BuildStatus = "draft" | "active" literal union is cleaner than enums for this two-state model
- Demotion rule: Active→Draft always succeeds enables users to revert and edit without validation concerns

### Codebase Patterns Discovered:
- Status Manager: Static class pattern with pure functions enables easy testing and composability
- Transition Results: Include success, newStatus, reason, and timestamp for complete audit trail
- Helper Functions: Static methods for formatting (getStatusLabel) and suggestions (getSuggestedAction)
- Validation Integration: Status manager accepts optional BuildValidationStatus to enforce constraints
- Possible Actions: getPossibleTransitions enables UI to show only valid action buttons

---

## Jan 8, 2026 - benchtop-7ql: Design form actions contract for chat integration

### What I Implemented:
- Created comprehensive form actions contract document at `src/lib/model/data/formActionsContract.ts`
- Defined 5 CopilotKit-exposed form operations: addWorkUnit, editWorkUnit, removeWorkUnit, setDependencies, changeBOM
- For each action, specified: inputs with detailed field documentation, preconditions for safety, state changes, outputs, and error cases
- Created standard ActionResult interface for consistent response format across all actions
- Documented integration points: state refresh requirements, data persistence, validation integration, error handling

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/formActionsContract.ts` — Complete form actions contract with 5 action definitions

### Learnings (for next iteration):
- Action preconditions are critical: all form operations require draft status (active builds must be demoted first)
- State changes should be immutable: create new builds rather than mutating existing ones
- Clearing validation results after mutations ensures consistent revalidation workflow
- Error cases should be exhaustive: include status checks, existence checks, circular dependency detection, invalid field validation
- Cascade updates are necessary: when removing steps, cleanup dependsOn arrays in dependent steps automatically
- Menu item changes (changeBOM) require clearing all steps since new BOMs have different component structures
- Version increment needed for conflict detection and audit trails (important for multi-user scenarios)

### Codebase Patterns Discovered:
- Form Actions: Define as discriminated union type with { type: "actionName" } + inputs for type-safe dispatch
- Action Results: Standardized interface with status, message, updatedBuild (on success), reason (on error)
- Preconditions: Always check build status first, then resource existence, then logical validity
- Error Messages: Should be specific ("Cannot add step to active build (demote first)") not generic
- State Safety: Keep form state unchanged on error—no partial updates or rollback needed
- Integration with Validation: Clear cached results on mutations so user sees "needs validation" state
- Dependency Validation: Detect circular dependencies using graph traversal before accepting updates

---

## Jan 8, 2026 - benchtop-x0c.3.1: Implement form step list component (linear, collapsible)

### What I Implemented:
- Created StepList component at `src/components/form/StepList.tsx` with full acceptance criteria
- Displays all WorkUnits from a LineBuild in vertical, scrollable list
- Each step shows: ID badge, action type, target item name, dependencies badge
- Collapsible/expandable section showing all WorkUnit tag details (time, phase, station, equipment, etc.)
- Includes empty states for: no build loaded, build has no steps, and loading state
- Step selection support (parent component handles selection for step editor integration)
- Dependency visualization: shows "depends on X" and "blocks Y" badges
- Full header showing menu item name and step count

### Files Changed:
- `apps/line-build-mvp/src/components/form/StepList.tsx` — Complete step list component (250 lines)

### Learnings (for next iteration):
- Component structure: Use child component (StepListItem) for each step to keep logic organized
- State management: Local expanded state via useState hook for collapsible sections
- Dependency tracking: Calculate dependents by filtering all steps for dependsOn references
- Empty states: Use flex centering pattern for loading, no-build, and no-steps states
- Selection highlighting: Use border-left accent and bg color change for visual feedback
- Scrolling: Flex layout with flex-1 overflow-y-auto on container, not children
- Accessibility: Include aria-labels on buttons and semantic onClick handlers
- Detail display: Show all WorkUnit tags in expanded section with proper formatting/spacing
- Badge styling: Use subtle colored backgrounds (amber for depends, green for blocks) with borders
- Lucide icons: Import ChevronDown/Up from lucide-react for expand/collapse

### Codebase Patterns Discovered:
- Component Structure: Use 'use client' directive for client-side components with hooks
- Props Interface: Create detailed interface with optional handlers and state props
- State Hooks: Local state for UI (expanded), parent props for data and selection
- Conditional Rendering: Use shorthand (&&) for simple conditions, ternary for state-based rendering
- Event Handling: Use stopPropagation on nested buttons to prevent parent handler firing
- Styling Pattern: Tailwind classes with conditional cn() patterns for state-based styling
- List Rendering: Always provide key prop, use semantic ul/li elements
- Typography: Use font-mono for IDs, semantic sizing (text-sm for content), muted colors for secondary info
- Spacing: Consistent px-4 py-3 padding, divide-y for list separators, mt-1 for related items

---

## Jan 8, 2026 - benchtop-x0c.3.2: Implement step editor form for WorkUnit tags

### What I Implemented:
- Created StepEditor component at `src/components/form/StepEditor.tsx` with full form for editing WorkUnit properties
- Core section: action type dropdown, target item name field, BOM ID field, equipment field
- Collapsible timing section: duration value + unit selector, active/passive toggle, add/remove time capability
- Collapsible phase & timing section: phase dropdown, timing mode dropdown, prep type dropdown
- Collapsible station & storage section: station field, storage location field
- Collapsible flags section: requiresOrder and bulkPrep checkboxes
- Real-time state updates via onChange callback
- Loading and empty states
- Field validation (required action, positive duration values)
- Built-in CollapsibleSection helper component for consistent collapsible patterns

### Files Changed:
- `apps/line-build-mvp/src/components/form/StepEditor.tsx` — Complete step editor component (400+ lines)

### Learnings (for next iteration):
- Enum values: Define const arrays at top (ACTION_TYPES, PHASES, etc.) for use in both dropdowns and type definitions
- Optional time object: Support add/remove time button since time is optional on WorkUnit
- State immutability: Use spread operators to create new objects rather than mutating (matches LineBuild pattern)
- Collapsible state: Use string keys in object for multiple independent sections
- Number validation: Use min="0" on numeric inputs and parseInt with >= 0 check to prevent negative values
- Toggle buttons: Use conditional className with ternary for active/inactive styling
- Select with empty option: Include `<option value="">No [Field]</option>` for optional dropdowns
- Partial updates: Pass Partial<WorkUnit> to onChange, letting parent handle merging with existing data
- BOM ID note: Document in placeholder that 40* = consumables, 80* = menu items
- Boolean flags: Use undefined instead of false to keep JSON clean (no storing false values)

### Codebase Patterns Discovered:
- Form Structure: Organize into logical sections with collapsible helpers for advanced fields
- Collapsible Pattern: Create reusable CollapsibleSection component with title, toggle handler, children
- Enum Handling: Define const arrays and use in both type definitions and dropdown rendering
- Optional Fields: Use `field || undefined` pattern to exclude false boolean values from updates
- Partial Updates: Parent component handles merging partial updates with full object state
- Number Fields: Validate with parseInt and >= 0 check before updating state
- Callback Pattern: Use onChange(updates) for parent to handle state merge and persistence
- Loading/Empty: Consistent patterns for loading spinner and empty state messaging
- Time Object: Support adding/removing optional complex objects with add/remove buttons

---

## Jan 8, 2026 - benchtop-x0c.3.3: Implement dependencies multi-select (explicit deps)

### What I Implemented:
- Created DependenciesMultiSelect component at `src/components/form/DependenciesMultiSelect.tsx`
- Multi-select dropdown with all other steps (excludes current step and already selected)
- Selected dependencies displayed as blue chips with remove button
- Searchable autocomplete dropdown filtering by step ID or action type
- Comprehensive validation: self-references, circular dependencies, already selected
- Circular dependency detection using recursive graph traversal
- Click-outside detection to close dropdown
- Real-time updates via onChange callback
- Dependency count badge in label
- Info text explaining purpose

### Files Changed:
- `apps/line-build-mvp/src/components/form/DependenciesMultiSelect.tsx` — Multi-select component (260 lines)

### Learnings (for next iteration):
- Circular dependency detection: Recursive hasDependencyPath function with visited set to prevent infinite loops
- Graph traversal: When checking cycles, need to traverse transitive dependencies (A→B→C)
- Search filtering: Support both ID and action type searches for better UX
- Click-outside: Use useRef on container + useEffect with mousedown listener for clean dropdown closing
- Chip removal: Provide X button on chips for easier removal than dragging to dropdown
- Available steps: Filter out current step and already-selected steps to avoid confusion
- Error states: Show contextual error messages (self-reference, circular, duplicate)
- Dropdown positioning: Use absolute positioning with top-full for dropdown below trigger
- Accessibility: Include aria-labels on remove buttons and focus management (autoFocus on input)
- Empty state: Handle no available steps gracefully with appropriate message

### Codebase Patterns Discovered:
- Multi-select Pattern: Use chips for selected items + dropdown for additions
- Circular Dependency: Recursive graph traversal with visited set to detect cycles
- Click-outside Detection: useRef + useEffect with document.addEventListener('mousedown')
- Search Integration: Filter list by input with multiple field support (ID, action)
- Validation Messages: Show specific error context (e.g., what creates the cycle)
- Dropdown UI: Search input at top, scrollable list, click-outside to close
- State Management: isOpen, searchQuery, error managed in component state
- Callbacks: onChange with updated array, validation before calling

---

## Jan 8, 2026 - benchtop-x0c.3.5: Implement BOM autocomplete (select by itemId)

### What I Implemented:
- Created BOMAutocomplete component at `src/components/form/BOMAutocomplete.tsx`
- Searchable dropdown using mock BOM catalog (getAllBOMItems from mockBom)
- Real-time filtering by item ID or item name
- Minimum 2-character search threshold with helpful message
- Display format: "itemId: itemName" with type label badge
- Keyboard navigation: arrow keys, enter to select, escape to close
- Click-outside detection for dropdown closure
- Optional filtering by item type (e.g., [40*] for consumables only)
- Graceful handling of no results and search threshold states
- Highlighted current selection in dropdown
- Type badges showing item classification (Ingredient, Consumable, etc.)

### Files Changed:
- `apps/line-build-mvp/src/components/form/BOMAutocomplete.tsx` — Autocomplete component (250+ lines)

### Learnings (for next iteration):
- itemId vs id: Mock BOM uses itemId (not id), match interface to real data types
- Null safety: getItemTypeFromId returns string | null, need (prefix && typeMap[prefix]) pattern
- Search threshold: Require minimum 2 chars to prevent showing all 200+ items
- Keyboard handling: Manage highlighted index state separately for arrow key navigation
- Click-outside: Use useRef on container + mousedown listener (not click) to close dropdown
- Type display: Extract type labels via getItemTypeFromId function from mockBom
- Display format: Show both itemId and name with colon separator for clarity
- Arrow key interaction: Update highlightedIndex without triggering selection
- Enter key: Select current highlighted item when dropdown is open
- Search efficiency: Filter available items once, then filter again by search for O(n) performance

### Codebase Patterns Discovered:
- Autocomplete Pattern: Trigger input, search threshold, filtered list, selection callback
- Keyboard Navigation: Separate highlighted index state, handle arrow keys + enter
- Click-outside Detection: useRef on container + useEffect with mousedown listener
- Type Filtering: Optional filterByType prop enables reusable component for different item types
- Display Format: Show "id: name" format with type badge for context
- Search UI: Show helpful messages (type threshold, no results, no available items)
- Highlighting: Use conditional className with highlightedIndex === index
- Graceful Degradation: Handle null/invalid types with fallback 'Item' label

---

## Jan 8, 2026 - benchtop-x0c.5.1: Implement chat UI with message history

### What I Implemented:
- Created ChatPanel component at `src/components/chat/ChatPanel.tsx`
- Message feed displaying user/assistant/system bubbles with distinct styling
- Auto-scroll to latest message using useRef and useEffect
- Message timestamps shown below each message
- Clear history button with confirmation dialog (prevents accidental deletion)
- Input field with send button (both keyboard and button submission)
- Loading state with animated dots while waiting for AI response
- Empty state messaging when no messages exist
- Support for Shift+Enter for new lines, Enter to send
- All messages ready for persistence in LineBuild.metadata.sourceConversations[]
- Disabled input/button while loading

### Files Changed:
- `apps/line-build-mvp/src/components/chat/ChatPanel.tsx` — Chat UI component (260 lines)

### Learnings (for next iteration):
- Auto-scroll: Use useRef on end element + useEffect with { behavior: 'smooth' }
- Message styling: Different bg colors for user (blue), assistant (green), system (gray)
- Confirmation dialog: Show modal for destructive actions (clear history)
- Loading state: Animate dots with staggered animation-delay for bouncing effect
- Timestamp formatting: Use toLocaleTimeString with specific options for consistent format
- Input handling: Check for trim() before calling callback, clear on send
- Keyboard shortcuts: Enter to send, Shift+Enter for new line in input
- Empty state: Show in flex center container with helpful message
- Disabled state: Disable input and button while isLoading to prevent duplicate sends
- Message structure: id, role, content, timestamp (ISO 8601) for persistence

### Codebase Patterns Discovered:
- Message Bubble: Separate component with avatar, content, timestamp
- Role-based Styling: Different bg/text colors per role (user/assistant/system)
- Avatar: Short letter (U/A/S) in colored circle, positioned by role
- Auto-scroll: useRef on end element, call scrollIntoView in useEffect
- Confirmation Dialog: Modal with backdrop, separate clear confirm state
- Input Validation: Check trim() before send, disable while loading
- Loading Animation: Bouncing dots with staggered delays using CSS animation-delay
- Timestamp Display: Only show if successfully parsed, use try/catch
- Accessible Buttons: aria labels, disabled state, hover effects
- Message Persistence: Structure ready for sourceConversations[] array in metadata

---

## Jan 8, 2026 - benchtop-x0c.5.2: Implement chat inline cards (interactive option selectors)

### What I Implemented:
- Created InlineCard component at `src/components/chat/InlineCard.tsx` with full interactivity
- CardOption interface with id, label, value, and optional description
- Single-select mode: clicking an option auto-submits immediately
- Multi-select mode: clicking toggles options in array, explicit submit button required
- Visual feedback: selected options highlighted with blue ring and filled circle indicator
- Responsive design with card layout, proper spacing, and mobile-friendly buttons
- Loading state disables all interactions with opacity feedback
- Selection counter shows how many items selected (multi-select) or confirms submission (single-select)

### Files Changed:
- `apps/line-build-mvp/src/components/chat/InlineCard.tsx` — Complete inline card component (170 lines)

### Learnings (for next iteration):
- Single vs Multi-select behavior: Single-select auto-submits on click, multi-select requires explicit submit button
- Selection indicator: Blue-filled circle (not checkbox) gives cleaner appearance and better UX
- Click handlers: Use disabled prop to gate interaction, set opacity-50 for visual feedback
- Callback pattern: onSubmit receives array of selectedIds, letting parent handle integration
- State management: Keep selectedIds in component state, don't mutate parent state directly
- Responsive: Use w-full for buttons, max-w-lg on card, ensure touch targets are >=44px
- Role attributes: Use role="group" and aria-label on container for accessibility
- Feedback: Show selection counter at bottom to confirm choices made

### Codebase Patterns Discovered:
- Card Component: Use border + shadow-sm + hover:shadow-md for interactive visual feedback
- Selection UI: Blue accent color (blue-500/blue-600) matches form inputs and primary actions
- Option Buttons: Full-width for touch targets, text-left alignment for left-to-right reading
- Disabled State: opacity-50 + cursor-not-allowed + prevent onClick handler execution
- Multi-line Text: Use description field with text-xs gray-600 for secondary info
- Loading State: Show "Loading..." text and disable all controls until complete
- State Patterns: selectedIds array managed in component, passed to parent via onSubmit

---

## Jan 8, 2026 - benchtop-x0c.5.4: Implement CopilotKit actions to update form/steps

### What I Implemented:
- Created Zustand store at `src/lib/model/store/formStore.ts` for global form state management
  - Manages currentBuild, selectedStepId, and isLoading
  - Implements all 5 form actions: addWorkUnit, editWorkUnit, removeWorkUnit, setDependencies, changeBOM
  - Built-in circular dependency detection using recursive graph traversal
  - Precondition checks for draft status, self-references, and invalid operations
- Created FormActionExecutor at `src/lib/model/data/formActionExecutor.ts` 
  - Pure function executor following formActionsContract
  - Returns ActionResult with status, message, updatedBuild (on success), reason (on error)
  - Comprehensive validation: draft status, field existence, circular dependencies, type safety
  - Creates new immutable LineBuild objects (no mutations)
  - Version increment on every mutation for conflict detection
- Created CopilotKit hooks at `src/lib/copilotkit/formActions.ts`
  - useCopilotFormActions hook for easy integration with CopilotKit useAction
  - Wraps FormActionExecutor calls with loading state management
  - Auto-persists to LineBuildPersistence after successful mutations
  - Graceful error handling with fallback to in-memory state

### Files Changed:
- `apps/line-build-mvp/src/lib/model/store/formStore.ts` — Zustand store for form state (340 lines)
- `apps/line-build-mvp/src/lib/model/data/formActionExecutor.ts` — Action executor (390 lines)
- `apps/line-build-mvp/src/lib/copilotkit/formActions.ts` — CopilotKit hooks (150 lines)

### Learnings (for next iteration):
- Zustand store pattern: create({ state, actions }) where actions use (set, get) to access/update state
- FormActionExecutor: Pure functions make testing easy, no side effects, return ActionResult for UI feedback
- Circular dependency detection: Recursive traversal with visited Set to prevent infinite loops
- Immutable updates: Always create new objects with spread operators, never mutate build.workUnits directly
- Error-first validation: Check preconditions (draft status, field existence) before attempting mutations
- Metadata versioning: Increment version on every mutation for conflict detection and undo/redo support
- Type safety: Use discriminated unions (type field) for FormActionInput to enable TypeScript narrowing
- Persistence integration: Call getPersistence().save() after mutations, but don't block on errors
- Loading states: Use store.setLoading during async operations to disable UI while persisting

### Codebase Patterns Discovered:
- State Management: Zustand store with (set, get) pattern, no Redux complexity
- Action Pattern: Execute function returns ActionResult {status, message, updatedBuild?, reason?}
- Preconditions: Check isDraft, field existence, dependency validity BEFORE mutating
- Immutability: Spread {...build, workUnits: [...workUnits]} to create new objects
- Validation: Circular dependency detection with recursive hasDependencyPath function
- Persistence: Async save after mutations, fallback to in-memory if storage fails
- Error Handling: Return ActionResult with clear error messages, keep form state unchanged on failure
- CopilotKit Integration: useCopilotFormActions hook provides action functions for useAction registration

---

## Jan 8, 2026 - benchtop-x0c.7.4: Define normalized validation result schema

### What I Implemented:
- Created comprehensive validation result schema documentation at `src/lib/model/data/validationResultSchema.ts`
- Documents ValidationResult interface (already defined in types.ts) with detailed field descriptions
- Shows normalized schema for both structured and semantic validation results
- Provides concrete JSON examples for different validation scenarios (pass/fail, with/without reasoning)
- Defines ValidationEngine interface that all validators must implement
- Documents aggregation schemas: ValidationResultSet and BuildValidationStatus
- Explains how validation results are used: Draft→Active transition gating, UI display, aggregation

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/validationResultSchema.ts` — Schema documentation (180 lines)

### Learnings (for next iteration):
- ValidationResult schema has both structured and semantic fields but reasoning is optional
- failures array is always present but empty when pass is true
- reasoning field is only populated for semantic rules (structured rules don't need it)
- ValidationResultSet aggregates results from a single validation run
- BuildValidationStatus is the aggregated view used for Draft→Active gating decision
- Both engines (structured and semantic) must produce same schema for consistent UI
- Timestamp on each result enables tracking when validation was performed
- workUnitId in result enables per-step feedback in UI

### Codebase Patterns Discovered:
- Schema Documentation: Create .ts file with interfaces, examples, and usage context
- Result Format: {ruleId, ruleName, ruleType, workUnitId, pass, failures[], reasoning?, timestamp}
- Failures Array: Always present, empty when pass is true, contains multiple reasons if applicable
- Reasoning Field: Optional, only for semantic rules, provides AI explanation
- Aggregation: Use BuildValidationStatus to summarize overall build validation state
- Engine Contract: ValidationEngine interface defines methods both validators implement
- Type Re-exports: Re-export from types.ts for convenience in schema file

---

---

## Session Summary - Jan 8, 2026

**Completed Tasks (3/5 ready):**
1. benchtop-x0c.5.2 ✅ - Chat inline cards component with single/multi-select modes
2. benchtop-x0c.5.4 ✅ - CopilotKit form actions with Zustand store and FormActionExecutor
3. benchtop-x0c.7.4 ✅ - Validation result schema documentation

**Still Ready (2 tasks):**
- benchtop-x0c.7.1 - Structured rules evaluator (P0)
- benchtop-x0c.7.2 - Semantic rules via Gemini (P0)

**Architecture Progress:**
- Chat layer: ChatPanel → InlineCard (options selection)
- Form layer: Form components → CopilotKit actions → FormActionExecutor → Zustand store
- Validation layer: Schema defined, ready for evaluator implementations

**Key Implementations:**
- Zustand store pattern for form state management
- FormActionExecutor with 5 form mutations (add/edit/remove steps, set dependencies, change BOM)
- Circular dependency detection algorithm
- CopilotKit hooks for easy action integration
- Normalized ValidationResult schema with examples

**Next Session Focus:**
- benchtop-x0c.7.1: Implement structured validation rule evaluator
- benchtop-x0c.7.2: Implement semantic validation using Gemini
- These will complete the validation engine MVP


## Jan 8, 2026 - benchtop-x0c.7.1: Validation engine - structured rules evaluator

### What I Implemented:
- Created StructuredValidationEvaluator class at `src/lib/model/data/structuredValidationEvaluator.ts`
- Evaluates StructuredValidationRules against LineBuild instances using condition-based logic
- Supports 5 condition operators: equals, in, notEmpty, greaterThan, lessThan
- Respects rule enablement and appliesTo action type filtering
- Returns ValidationResult objects conforming to normalized schema (from benchtop-x0c.7.4)
- Includes helper functions for nested field access and condition evaluation
- Provides summarizeResults utility for analyzing validation outputs

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/structuredValidationEvaluator.ts` — Complete structured evaluator (220+ lines)

### Learnings (for next iteration):
- Dot notation field access: Use split('.') to navigate nested objects like "tags.time.value"
- Condition operators: Five operators cover common validation patterns (exact match, set membership, existence, numeric comparisons)
- Rule filtering: Check rule.enabled and appliesTo before evaluating to avoid unnecessary processing
- Disabled/non-applicable rules return pass=true (don't block validation)
- Failure messages: Include expected vs. actual values for debugging (use JSON.stringify for complex types)
- Error cases: Handle rule config errors gracefully (e.g., 'in' operator with non-array value)
- Summary utility: Useful for UI display (pass count, fail count, failures grouped by WorkUnit)
- Pure functions: No side effects, no async, easy to test and compose with other validators

### Codebase Patterns Discovered:
- Evaluator Pattern: Static class with evaluateRule(single), evaluateBuild(all), and summarizeResults methods
- Condition Evaluation: Separate function for condition logic, returns { pass, failure? }
- Nested Field Access: Helper function using path.split('.') with undefined-safe traversal
- Rule Filtering: Check enabled and appliesTo before condition evaluation
- Error Messages: Include ${field}, ${operator}, ${expected}, ${actual} for debugging
- Type Safety: Return type is always ValidationResult, consistent schema across all evaluators
- No External Dependencies: Pure function approach enables testing without mocks

---

## Jan 8, 2026 - benchtop-x0c.7.2: Validation engine - semantic rules via Gemini

### What I Implemented:
- Created SemanticValidationEvaluator class at `src/lib/model/data/semanticValidationEvaluator.ts`
- Evaluates SemanticValidationRules against LineBuild instances using Gemini AI
- Builds rich WorkUnit context (action, equipment, timing, phase, station, dependencies) for Gemini prompts
- Sends rule prompt + context + guidance to Gemini, receives structured JSON response
- Parses Gemini response with robust JSON extraction (handles markdown-wrapped JSON)
- Returns ValidationResult with pass, failures[], and reasoning fields from AI
- Respects rule enablement and appliesTo action type filtering
- Graceful error handling: API failures return failure result with error message (not thrown)
- Includes helper functions: buildWorkUnitContext, parseGeminiResponse, summarizeResults

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/semanticValidationEvaluator.ts` — Complete semantic evaluator (250+ lines)

### Learnings (for next iteration):
- Gemini response format: Expect JSON with { pass, reasoning, failures } structure
- JSON extraction: Use regex /\{[\s\S]*\}/ to extract JSON from responses (handles markdown wrapping)
- Context building: Rich context (equipment, timing, dependencies) helps Gemini understand the work unit
- System instruction: Use guidance field from rule, fallback to generic instruction emphasizing JSON format
- Disabled/non-applicable rules: Return pass=true with explanatory reasoning
- Error handling: Catch Gemini errors and return failure result (don't propagate exception)
- Async pattern: Use async/await for AI calls, evaluateBuild iterates sequentially through WorkUnits
- Reasoning field: Always include reasoning from AI for transparency, even for disabled rules
- Response parsing: Validate parsed response has required fields (pass boolean) before returning

### Codebase Patterns Discovered:
- Semantic Evaluator: Similar interface to StructuredValidationEvaluator but async and uses external AI
- Gemini Integration: Use VertexAIClient.generateContent(prompt, systemInstruction) for calls
- Context Building: WorkUnit context string with all relevant fields, one per line, readable for Gemini
- Response Parsing: Try-catch with JSON regex extraction, validate required fields
- Error Handling: Return failure ValidationResult on API error (with error message in failures array)
- Type Safety: Same ValidationResult return type as structured evaluator for UI consistency
- Async Composition: evaluateBuild uses Promise chain, results collected in array
- Reasoning Extraction: Always include AI reasoning in result for audit trail and user transparency

---

## Jan 8, 2026 - benchtop-x0c.6.1: Validation UI - checklist panel (read-only status)

### What I Implemented:
- Created ValidationChecklistPanel component at `src/components/validation/ValidationChecklistPanel.tsx`
- Displays validation results as a read-only checklist with overall build status
- Shows per-rule pass/fail results grouped by WorkUnit with detailed failure reasons
- Collapsible result items: expand to see full reasoning from semantic rules
- Status badges: "All Clear" (green) vs. "N Issues" (red)
- Semantic rule results marked with "AI" badge; structured rules unmarked
- Draft vs. Active status indicator with publish readiness messaging
- "Re-run" button for running validation again
- Empty states: no results yet, no work units to validate
- Loading state overlay while validation runs
- Timestamp display for each result and last validation check time

### Files Changed:
- `apps/line-build-mvp/src/components/validation/ValidationChecklistPanel.tsx` — Validation UI component (400+ lines)

### Learnings (for next iteration):
- Component structure: Separate helper components (ValidationResultItem) for better organization
- Collapsible logic: Track expanded state by `ruleId-workUnitId` composite key
- Result styling: Use getResultStyling helper to centralize pass/fail appearance
- Grouping: Group results by workUnitId to organize checklist by step
- Status badges: Use distinct colors (emerald/red) with opacity variants for easy scanning
- Timestamp formatting: Use toLocaleTimeString() with try/catch for safety
- Empty states: Provide helpful guidance when no results or no steps exist
- Loading UI: Overlay with backdrop-blur-sm and centered spinner
- Semantic vs. Structured: Differentiate with type badge (only for semantic)
- Draft/Active messaging: Show different guidance based on validation status and publish readiness

### Codebase Patterns Discovered:
- Panel Component: Root container with header, scrollable content, loading overlay
- Status Display: Badge + metadata text (last checked, draft/active status)
- Result Item: Icon + label + failure list + collapsible details
- Grouping Pattern: Object.entries().map() to iterate grouped results
- Styling: Tailwind bg/border color variants (emerald/red/blue), opacity modifiers
- Empty State: Flex centered container with icon, message, optional action button
- Timestamp Display: Try/catch with toLocaleTimeString() for safety
- Collapsible Pattern: Separate component with onClick toggle, expanded state check
- Icon Handling: Lucide react icons (CheckCircle2, AlertCircle, ChevronUp/Down)
- Loading State: Absolute overlay with backdrop-blur-sm for visual feedback

---

## Jan 8, 2026 - benchtop-x0c.6.4: Validation gating - block Draft→Active if failures

### What I Implemented:
- Created PublishButton component at `src/components/validation/PublishButton.tsx`
- Enforces validation gating: Draft→Active transition blocked if validation failures exist
- Two modes: Draft mode with "Publish to Active" button, Active mode with "Demote to Draft" button
- Publish button disabled with explanatory message if validation failures present
- Shows specific reason why publish is blocked (structured/semantic failures, no validation run)
- Demote button always enabled (Active→Draft allowed without validation checks)
- Confirmation dialogs for both publish and demote actions
- Loading states during transition processing
- Visual feedback: icons, colors, messages showing validation status
- Integrates with BuildStatusManager for transition logic
- Shows validation issue count and guidance messages

### Files Changed:
- `apps/line-build-mvp/src/components/validation/PublishButton.tsx` — Publish/demote UI component (350+ lines)

### Learnings (for next iteration):
- Conditional rendering: Two distinct UIs for draft vs. active status
- Button state management: Disabled when no transitions possible or validation blocks publish
- Confirmation dialog: Separate component for modal handling, reused for publish and demote
- Validation gating: Use BuildStatusManager.canTransition() to check publish eligibility
- Error messaging: Show specific BlockingReason from StatusTransitionResult
- Guidance messages: Different messages for different scenarios (no validation, failures, ready, demoted)
- State management: confirmAction track which action requires confirmation
- Loading indicator: Show during async onPublish/onDemote callback
- Icons: Use Lock/LockOpen to visually communicate edit vs. publish states
- Responsive: Single button for each mode, not both at once

### Codebase Patterns Discovered:
- Conditional Mode UI: Branch on build.metadata.status to render draft or active UI
- Confirmation Dialog: Separate component with isOpen, title, message, confirmText
- Transition Logic: Use BuildStatusManager static methods for validation checks
- Blocking Reasons: Display publishResult.reason when canPublish is false
- Guidance Messages: Different text based on validationStatus.failureCount
- Loading State: setIsProcessing during async callback, disable button
- Icon Pairing: Use Lock for active (secure), LockOpen for draft (editable)
- Dialog Backdrop: Fixed overlay with z-50 and black/50 background
- Message Styling: Use different colors/icons for error/warning/success messages
- Callback Pattern: onPublish and onDemote async callbacks for parent state management

---
