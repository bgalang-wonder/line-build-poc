# Ralph Progress Log
Started: 2026-01-07

## Codebase Patterns
- App Router: Use `src/app` structure with Next.js 15
- Styling: Tailwind CSS
- AI: Gemini 2.5 Flash via Vertex AI (@google/genai)
- Persistence: JSON files in `src/lib/model/data`
- Components: Use Radix UI / Shadcn UI patterns where applicable
- Types: Export from `src/lib/model/types.ts`

## Domain: Item Types & IDs (Cookbook)
Items have 7-digit IDs where the first digit(s) signify the type:
- **5\*** = Ingredients (raw, lowest-level, procured externally)
- **3\*** = Benchtop recipes (R&D reference only, not production)
- **40\*** = Consumable Items (components in menu item BOMs)
- **80\*** = Menu items (have line builds, used in Spork for food production)
- **88\*** = Packaged goods (items we produce)
- **9\*** = Guest packaging items

## Domain: BOM Structure
- **Menu items (80\*)** have BOMs containing **40\* consumable items**
- BOM contains: input item IDs, quantities, units of measure, output amounts
- **Publishing Order**: Cannot publish if BOM contains draft items
- **Cost Flow**: Costs roll up from base items
- **Nutrition Flow**: Nutrition values flow through BOM hierarchy

## Key Files
- apps/archive-benchtop-mvp/ (Reference for porting logic)
- apps/archive-benchtop-mvp/src/lib/ai/vertex/client.ts (Vertex AI setup)
- apps/archive-benchtop-mvp/src/lib/model/types.ts (Type definitions)
- docs/PRD.md (Main reference for requirements)

## BD Commands
- `bd ready --json` — Get tasks ready to work on
- `bd show <id>` — Full issue details
- `bd update <id> --status in_progress` — Claim task
- `bd close <id>` — Mark complete
- `bd dep tree <id>` — Visualize dependencies

---
Ralph appends after each story.
Patterns accumulate across iterations.

## Jan 7, 2026 - benchtop-x0c.1.1: Scaffold new Next.js app (apps/line-build-mvp)

### What I Implemented:
- Created new Next.js 15 app in `apps/line-build-mvp` using create-next-app
- Configured with TypeScript, Tailwind CSS, ESLint, App Router, and src-dir structure
- Imported alias set to @/* for cleaner imports

### Files Changed:
- `apps/line-build-mvp/` — Complete new Next.js application scaffold

### Learnings (for next iteration):
- create-next-app with `--app --src-dir --import-alias '@/*'` creates the base structure needed
- Foundation ready for subsequent tasks (Vertex AI, CopilotKit, types, etc.)
- The app is now ready for dependency installations

### Codebase Patterns Discovered:
- Next.js setup: Use create-next-app with --app, --src-dir, --import-alias, --typescript, --tailwind flags

---

## Jan 7, 2026 - benchtop-x0c.1.2: Integrate Vertex AI client (Gemini)

### What I Implemented:
- Created Vertex AI client wrapper in `src/lib/ai/vertex/client.ts`
- Installed @google/genai package for Vertex AI/Gemini integration
- Implemented VertexAIClient class with generateContent method
- Added createVertexAIClient factory function with environment variable support

### Files Changed:
- `apps/line-build-mvp/src/lib/ai/vertex/client.ts` — Vertex AI client wrapper
- `apps/line-build-mvp/package.json` — Added @google/genai dependency

### Learnings (for next iteration):
- Use generateContentStream() instead of generateContent() for streaming responses (fixes async iterator type issues)
- Environment variables needed: VERTEX_AI_PROJECT, VERTEX_AI_LOCATION (default: us-central1), VERTEX_AI_MODEL (default: gemini-2.5-flash)
- GOOGLE_APPLICATION_CREDENTIALS environment variable handles authentication automatically
- The GoogleGenAI SDK handles Vertex AI routing automatically with vertexai: true flag

### Codebase Patterns Discovered:
- AI Integration: Use @google/genai with GoogleGenAI class and generateContentStream() for Vertex AI
- Config Pattern: Read environment variables with sensible defaults
- Error Handling: Wrap try/catch around AI calls with meaningful error messages

---

## Jan 7, 2026 - benchtop-x0c.1.3: Integrate CopilotKit (chat + tool actions)

### What I Implemented:
- Installed CopilotKit packages: @copilotkit/react-core, @copilotkit/react-ui, @copilotkit/runtime
- Created CopilotKitProvider wrapper component at `src/components/CopilotKitProvider.tsx`
- Wrapped root layout with CopilotKitProvider for app-wide chat availability
- Created placeholder API route at `src/app/api/copilotkit/route.ts` for backend integration

### Files Changed:
- `apps/line-build-mvp/src/components/CopilotKitProvider.tsx` — Client-side CopilotKit wrapper
- `apps/line-build-mvp/src/app/api/copilotkit/route.ts` — Placeholder backend route
- `apps/line-build-mvp/src/app/layout.tsx` — Wrapped with CopilotKitProvider
- `apps/line-build-mvp/package.json` — Added CopilotKit dependencies

### Learnings (for next iteration):
- CopilotKit requires '@copilotkit/react-ui/styles.css' import for styling
- CopilotKit v1.50.1+ ships with React 19 support (different from reference's v1.0.0)
- Provider wraps entire app at root layout for chat availability across all pages
- API route should handle POST requests to /api/copilotkit (placeholder ready for full implementation)
- Full backend integration will be done when CopilotKit actions are defined (benchtop-x0c.5.4)

### Codebase Patterns Discovered:
- CopilotKit Setup: Install packages, create Provider wrapper component, import styles.css
- Provider Pattern: Use 'use client' directive in provider component for client-side setup
- API Route Pattern: Create route handler at src/app/api/[name]/route.ts for Next.js 15+

---

## Jan 7, 2026 - benchtop-x0c.1.4: Define core types (LineBuild, WorkUnit, Override, ValidationRule)

### What I Implemented:
- Created comprehensive types file at `src/lib/model/types.ts`
- Defined LineBuild and WorkUnit types (based on reference implementation)
- Defined Override type for form field overrides with audit trail
- Defined ValidationRule types (StructuredValidationRule and SemanticValidationRule)
- Defined ValidationResult and BuildValidationStatus types for validation output
- All types follow TypeScript best practices with clear field descriptions

### Files Changed:
- `apps/line-build-mvp/src/lib/model/types.ts` — Complete type definitions for MVP

### Learnings (for next iteration):
- LineBuild uses status: "draft" | "active" (not "published" from reference)
- ValidationRule split into two types: structured (condition-based) and semantic (Gemini-based)
- StructuredValidationRule uses condition object with field/operator/value for rule logic
- SemanticValidationRule uses prompt/guidance for Gemini evaluation
- ValidationResult includes ruleType, reasoning field (for semantic rules), and timestamp
- Override tracks original/overridden values with timestamps for audit trail
- All date fields use ISO 8601 string format

### Codebase Patterns Discovered:
- Types: Export all types from src/lib/model/types.ts
- Type Organization: Group related types with section headers (// ========)
- Discriminated Unions: Use ValidationRuleType discriminator for rule type checking
- Status Enums: Use literal unions for status fields instead of string enums (more flexible)

---

## Jan 7, 2026 - benchtop-x0c.2.1: Implement JSON persistence for line builds

### What I Implemented:
- Created LineBuildPersistence class for save/load/delete operations on LineBuild objects
- Implemented timestamped backup system to prevent data loss and conflicts
- Added graceful error handling for corrupted JSON files with automatic recovery from backups
- Support for both Node.js (fs module) and browser (localStorage) storage backends
- Human-readable JSON formatting (2-space indent) for debugging and manual inspection
- Factory functions for instance management (getPersistence singleton, createPersistence for testing)
- Validation of LineBuild structure during load with meaningful error messages

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/persistence.ts` — Complete persistence implementation

### Learnings (for next iteration):
- Dual-environment persistence: Use dynamic imports (fs/promises, path) for Node.js detection
- Backups saved with timestamp pattern: `filename.backup.YYYY-MM-DDTHH-mm-ss` for sorting
- Corrupted file recovery: Try most recent backup first, skip to next on parse error
- Type assertion workaround: Use `as unknown as LineBuild` for complex destructuring patterns
- Directory creation: Use `fs.mkdir(..., { recursive: true })` for safe multi-path creation
- Error messages should include the buildId and operation context for debugging

### Codebase Patterns Discovered:
- Persistence API: Class-based with async methods matching save/load/delete/exists operations
- File Naming: Use buildId directly as filename (e.g., `build-123.json`)
- Environment Detection: Check `typeof window === "undefined"` to distinguish server/client
- Backup Storage: Keep backups in same directory with timestamp suffix for versioning
- Error Recovery: Three-tier strategy: primary file → recent backups → meaningful error message

---

## Jan 7, 2026 - benchtop-x0c.1.5: Create mock BOM dataset (7-digit itemId + name)

### What I Implemented:
- Created mock BOM catalog with realistic 7-digit item IDs following Cookbook conventions
- Defined items across all categories: menu items (80*), consumables (40*), ingredients (5*), packaged goods (88*), packaging (9*)
- Implemented 8 realistic menu items with complete names: "Grilled Chicken Bowl", "Crispy Fish Tacos", etc.
- Implemented 17 consumable items organized by type (proteins, vegetables, rice/noodles, sauces)
- Created 8 BOM recipes mapping menu items to their consumable components with realistic quantities
- Exported helper functions for easy access: getAllBOMItems, findBOMItem, getBOMRecipe, getItemTypeFromId

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/mockBom.ts` — Complete mock BOM dataset

### Learnings (for next iteration):
- Item ID prefixes are critical: 5* = ingredient, 40* = consumable, 80* = menu, 88* = packaged, 9* = packaging
- BOM relationships are unidirectional: menu items (80*) reference consumable items (40*)
- Consumable organization by category (proteins, vegetables, etc.) makes data more maintainable
- Helper functions reduce boilerplate in other components (forms, validation, autocomplete)
- Mock data should include realistic quantities and units (g, ml) for validator testing
- Export the entire catalog as MOCK_BOM_CATALOG object for easy integration

### Codebase Patterns Discovered:
- Mock Data Export: Define data as const arrays, export individually AND as aggregate object
- Helper Functions: Provide utility functions (findByID, getByType) for common queries
- Type Organization: Use interfaces for item structure (BOMItem, BOMRecipe) at top of file
- Naming: Use uppercase SNAKE_CASE for exported constants, lowercase camelCase for functions

---

## Jan 7, 2026 - benchtop-x0c.2.3: Implement JSON persistence for validation rules

### What I Implemented:
- Created ValidationRulesPersistence class for managing ValidationRule objects (both structured and semantic)
- Implemented full CRUD operations: saveRule, saveRules, loadAll, loadRule, loadRulesByType, updateRule, deleteRule
- Added backup and corruption recovery mechanisms (same pattern as LineBuildPersistence)
- Rules persisted as collection in single JSON file with metadata wrapper
- Type validation distinguishes between structured rules (with condition) and semantic rules (with prompt)
- Support for both server (fs) and client (localStorage) storage backends
- Singleton and test instance factory functions (getRulesPersistence, createRulesPersistence)

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/rulesPersistence.ts` — Complete rules persistence implementation

### Learnings (for next iteration):
- Rules collection pattern: Store all rules in single file (validation-rules.json) rather than per-rule files
- Metadata wrapper: Use {rules: [...], _metadata: {...}} pattern to include save timestamp and rule count
- Type guards: Use discriminated unions (type: "structured" | "semantic") to validate rule types
- Update merging: Use `as ValidationRule` type assertion after spreading to resolve complex union issues
- localStorage key prefix: Use "valrules:" prefix to avoid conflicts with other persistence layers
- Backup naming: Timestamp backups enable easy recovery of specific versions
- Load handling: Support both direct array [] and wrapped {rules: [...]} formats for flexibility

### Codebase Patterns Discovered:
- Rules Storage: Single collection file is better than per-rule files for managing relationships
- Type Validation: Discriminated union types (type field) enable clean type narrowing
- Error Recovery: Same three-tier strategy as LineBuildPersistence (primary → backup → error)
- localStorage Strategy: Use domain-specific prefixes (valrules:, linebuild:) to organize data
- Metadata Tracking: Include savedAt, version, and entity count in metadata for debugging

---

## Jan 7, 2026 - benchtop-x0c.2.2: Implement draft/active status model + transitions

### What I Implemented:
- Created BuildStatusManager class for enforcing state transitions with validation constraints
- Implemented transition rules: Active→Draft always allowed (demote without restriction), Draft→Active requires validation with zero failures
- Added canTransition for pre-flight checks and transitionTo for actual transitions with detailed blocking reasons
- Implemented applyTransition to safely apply status changes to LineBuild objects and persist in metadata
- Added UI helper functions: getStatusLabel, getStatusDescription, isEditableStatus, getSuggestedAction
- Implemented getPossibleTransitions to show available actions from current status
- Status persists in LineBuild.metadata.status (already supported by LineBuildPersistence)
- Validation constraints: requires BuildValidationStatus with !hasStructuredFailures && !hasSemanticFailures

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/statusManager.ts` — Complete status transition manager

### Learnings (for next iteration):
- Transition rules: Always provide detailed blocking reasons in StatusTransitionResult.reason field
- Validation coupling: Draft→Active transition depends on BuildValidationStatus, need to run validation first
- Metadata persistence: Status in LineBuild.metadata is persisted by LineBuildPersistence automatically
- UI helpers: Helper functions (getStatusLabel, getStatusDescription, getSuggestedAction) enable consistent UI display
- Immutability: Use spread operators to create new builds rather than mutating existing ones
- Type safety: BuildStatus = "draft" | "active" literal union is cleaner than enums for this two-state model
- Demotion rule: Active→Draft always succeeds enables users to revert and edit without validation concerns

### Codebase Patterns Discovered:
- Status Manager: Static class pattern with pure functions enables easy testing and composability
- Transition Results: Include success, newStatus, reason, and timestamp for complete audit trail
- Helper Functions: Static methods for formatting (getStatusLabel) and suggestions (getSuggestedAction)
- Validation Integration: Status manager accepts optional BuildValidationStatus to enforce constraints
- Possible Actions: getPossibleTransitions enables UI to show only valid action buttons

---

## Jan 8, 2026 - benchtop-7ql: Design form actions contract for chat integration

### What I Implemented:
- Created comprehensive form actions contract document at `src/lib/model/data/formActionsContract.ts`
- Defined 5 CopilotKit-exposed form operations: addWorkUnit, editWorkUnit, removeWorkUnit, setDependencies, changeBOM
- For each action, specified: inputs with detailed field documentation, preconditions for safety, state changes, outputs, and error cases
- Created standard ActionResult interface for consistent response format across all actions
- Documented integration points: state refresh requirements, data persistence, validation integration, error handling

### Files Changed:
- `apps/line-build-mvp/src/lib/model/data/formActionsContract.ts` — Complete form actions contract with 5 action definitions

### Learnings (for next iteration):
- Action preconditions are critical: all form operations require draft status (active builds must be demoted first)
- State changes should be immutable: create new builds rather than mutating existing ones
- Clearing validation results after mutations ensures consistent revalidation workflow
- Error cases should be exhaustive: include status checks, existence checks, circular dependency detection, invalid field validation
- Cascade updates are necessary: when removing steps, cleanup dependsOn arrays in dependent steps automatically
- Menu item changes (changeBOM) require clearing all steps since new BOMs have different component structures
- Version increment needed for conflict detection and audit trails (important for multi-user scenarios)

### Codebase Patterns Discovered:
- Form Actions: Define as discriminated union type with { type: "actionName" } + inputs for type-safe dispatch
- Action Results: Standardized interface with status, message, updatedBuild (on success), reason (on error)
- Preconditions: Always check build status first, then resource existence, then logical validity
- Error Messages: Should be specific ("Cannot add step to active build (demote first)") not generic
- State Safety: Keep form state unchanged on error—no partial updates or rollback needed
- Integration with Validation: Clear cached results on mutations so user sees "needs validation" state
- Dependency Validation: Detect circular dependencies using graph traversal before accepting updates

---

## Jan 8, 2026 - benchtop-x0c.3.1: Implement form step list component (linear, collapsible)

### What I Implemented:
- Created StepList component at `src/components/form/StepList.tsx` with full acceptance criteria
- Displays all WorkUnits from a LineBuild in vertical, scrollable list
- Each step shows: ID badge, action type, target item name, dependencies badge
- Collapsible/expandable section showing all WorkUnit tag details (time, phase, station, equipment, etc.)
- Includes empty states for: no build loaded, build has no steps, and loading state
- Step selection support (parent component handles selection for step editor integration)
- Dependency visualization: shows "depends on X" and "blocks Y" badges
- Full header showing menu item name and step count

### Files Changed:
- `apps/line-build-mvp/src/components/form/StepList.tsx` — Complete step list component (250 lines)

### Learnings (for next iteration):
- Component structure: Use child component (StepListItem) for each step to keep logic organized
- State management: Local expanded state via useState hook for collapsible sections
- Dependency tracking: Calculate dependents by filtering all steps for dependsOn references
- Empty states: Use flex centering pattern for loading, no-build, and no-steps states
- Selection highlighting: Use border-left accent and bg color change for visual feedback
- Scrolling: Flex layout with flex-1 overflow-y-auto on container, not children
- Accessibility: Include aria-labels on buttons and semantic onClick handlers
- Detail display: Show all WorkUnit tags in expanded section with proper formatting/spacing
- Badge styling: Use subtle colored backgrounds (amber for depends, green for blocks) with borders
- Lucide icons: Import ChevronDown/Up from lucide-react for expand/collapse

### Codebase Patterns Discovered:
- Component Structure: Use 'use client' directive for client-side components with hooks
- Props Interface: Create detailed interface with optional handlers and state props
- State Hooks: Local state for UI (expanded), parent props for data and selection
- Conditional Rendering: Use shorthand (&&) for simple conditions, ternary for state-based rendering
- Event Handling: Use stopPropagation on nested buttons to prevent parent handler firing
- Styling Pattern: Tailwind classes with conditional cn() patterns for state-based styling
- List Rendering: Always provide key prop, use semantic ul/li elements
- Typography: Use font-mono for IDs, semantic sizing (text-sm for content), muted colors for secondary info
- Spacing: Consistent px-4 py-3 padding, divide-y for list separators, mt-1 for related items

---
